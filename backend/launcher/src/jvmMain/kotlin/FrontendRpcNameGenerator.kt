package dk.sdu.cloud

import dk.sdu.cloud.calls.HttpMethod
import dk.sdu.cloud.calls.httpOrNull
import dk.sdu.cloud.calls.toPath
import java.io.File

fun generateFrontendRpcNameTable(
    containers: Collection<List<GeneratedRemoteProcedureCall>>,
) {
    val baseDirectory = File("../../frontend-web/webclient/app/Authentication").takeIf { it.exists() }
        ?: File("/opt/frontend/app/Authentication").takeIf { it.exists() }

    if (baseDirectory == null) return

    val matchers = HashMap<HttpMethod, ArrayList<FrontendRpcMatcher>>()

    for (generatedCall in containers.asSequence().flatten()) {
        val call = generatedCall.realCall
        val http = call.httpOrNull ?: continue

        val matcherList = matchers.getOrPut(http.method) { ArrayList() }
        matcherList.add(FrontendRpcMatcher.Exact(http.path.toPath(), call.fullName))
    }

    val output = buildString {
        appendLine(
            """
            //
            // Generated by `./run.sh --run-script api-gen` from the backend. Do not modify this file!
            //
            
            import { CallParameters } from "@/Authentication/CallParameters";
            
            export function estimateRpcName(params: CallParameters): string | null {
                const method = params.method;
                let path = params.path;
                const queryBegin = path.indexOf("?");
                const beforeQuery = queryBegin === -1 ? path : path.substring(0, queryBegin);
                path = beforeQuery;
                if (beforeQuery.length > 1 && beforeQuery[beforeQuery.length - 1] === '/') {
                    path = beforeQuery.substring(0, beforeQuery.length - 1);
                }
                if (params.context === undefined) {
                    path = "/api" + path;
                } else if (params.context !== "") {
                    path = params.context + path;
                }
                
                path = "/" + path.split("/").filter(it => it.trim().length > 0).join("/");
                
                switch (method) {
            """.trimIndent()
        )

        for ((method, endpoints) in matchers) {
            appendLine("case '${method.value}':")
            appendLine("switch (path) {")
            for (endpoint in endpoints) {
                when (endpoint) {
                    is FrontendRpcMatcher.Exact -> {
                        val shouldSkipEndpoint = endpoint.rpcName.contains(".PROVIDERID.") ||
                            endpoint.rpcName.startsWith("example.")

                        if (!shouldSkipEndpoint) {
                            appendLine("case '${endpoint.path}': return '${endpoint.rpcName}';")
                        }
                    }
                }
            }
            appendLine("}")
            appendLine("break;")
        }

        appendLine("}")
        appendLine("console.warn('Could not resolve RPC name, this will probably break something! " +
            "A developer should run `./run.sh --run-script api-gen` from the backend', params);")
        appendLine("return null;")
        appendLine("}")
    }

    File(baseDirectory, "RpcNameTable.ts").writeText(output)
}

private sealed class FrontendRpcMatcher {
    data class Exact(val path: String, val rpcName: String) : FrontendRpcMatcher()
}
