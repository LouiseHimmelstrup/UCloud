package = h2o
headers = h2o.h h2o/websocket.h wslay/wslay.h
staticLibraries = libh2o.a libwslay.a
libraryPaths = vendor/libh2o/linux
linkerOpts = -L/usr/lib/x86_64-linux-gnu -lssl -lcrypto
headerFilter = h2o.h h2o/** wslay/**

---

// Needed to circumvent parts of Kotlin/Native memory management
static h2o_accept_ctx_t accept_ctx;

// This part is just straight up missing
typedef void* h2o_evloop_t;
h2o_socket_t *h2o_evloop_socket_create(h2o_evloop_t *loop, int fd, int flags);
h2o_socket_t *h2o_evloop_socket_accept(h2o_socket_t *listener);

// Fix added because the original API does _not_ play well with KStrings. This requires a string which is natively
// allocated to work correctly.
void h2o_add_header_kt(h2o_mem_pool_t *pool, h2o_headers_t *headers, const h2o_token_t *token, void *orig_name,
                    void *value, size_t value_len) {
    h2o_add_header(pool, headers, token, (char *) orig_name, (char *) value, value_len);
}

int h2o_upgrade_websocket_if_needed(h2o_req_t *req, h2o_websocket_msg_callback cb) {
    const char *client_key;
    int is_handshake = h2o_is_websocket_handshake(req, &client_key) == 0;
    if (!is_handshake) return 0;
    if (client_key == NULL) return 0;
    h2o_upgrade_to_websocket(req, client_key, NULL, cb);
    return 1;
}