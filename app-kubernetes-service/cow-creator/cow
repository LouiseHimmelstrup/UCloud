#!/usr/bin/env bash

# Manages the PV type cow.
#
# Dependencies:
# - overlayfs kernel driver (patched with support for CephFS)
# - cephfs kernel driver
# - jq

# The overlay fs driver in the kernel has troubles supporting CephFS. This happens during the copy_up procedure when
# copying extended attribtues. The internal `ceph.*` attributes are not meant to be copied. As a result Ceph will
# return not supported for all copies of internal attributes. This causes OverlayFS to fail entirely. We have added a
# patch in our kernel which skips all internal ceph attributes.

#exec &> >(tee -ai /tmp/log.txt)

log() {
    echo -ne $* >&1
}

PATH=$PATH:$(dirname "$0")/.bin
cephfs_mount=/mnt/cephfs

ismounted() {
    query=$1
    mount=$(findmnt -n "${query}" 2>/dev/null | cut -d' ' -f1)
    if [ "${mount}" == "${query}" ]; then
        echo "1"
    else
        echo "0"
    fi
}

mountcephfs() {
    if [ $(ismounted $cephfs_mount) -eq 0 ]; then
        mons=$(echo $1 | jq -r '."kubernetes.io/secret/cephMon"' | base64 -d)
        user=$(echo $1 | jq -r '."kubernetes.io/secret/cephUser"' | base64 -d)
        key=$(echo $1 | jq -r '."kubernetes.io/secret/cephKey"' | base64 -d)

        mkdir -p "${cephfs_mount}" &>/dev/null
        mount -t ceph "${mons}:/" "${cephfs_mount}" -o "name=${user},secret=${key}" &>/dev/null
    fi
}

domount() {
    # Prepare input
    mntpath=$1
    shift
    request=$*
    workspace=$(echo $request | jq -r .workspace)
    directory_name=$(echo $request | jq -r .directoryName)
    snapshot_path=$(echo $request | jq -r .snapshotPath)
    real_path=$(echo $request | jq -r .realPath)
    tmp_storage=$(echo $request | jq -r .tmpStorage)
    sub_directory=$(echo $request | jq -r .cephSubDir)

    if [ ! "$workspace" ]
    then
        exit 1
    fi

    if [ ! "$tmp_storage" ]
    then
        tmp_storage="/mnt/ofs"
    fi

    if [ "$tmp_storage" == "null" ]
    then
        tmp_storage="/mnt/ofs"
    fi

    if [ "$sub_directory" == "null" ]
    then
        sub_directory=""
    fi

    # Mount lower directory
    mountcephfs $request

    # Allocate upper and work directories
    tmp_work="${tmp_storage}/${workspace}_${directory_name}"
    mkdir -p "${tmp_work}/upper"
    mkdir -p "${tmp_work}/work"

    # Save metadata for later use
    mkdir -p /tmp/snaps &>/dev/null
    metadata_file="/tmp/snaps/$(echo $mntpath | md5sum | awk '{ print $1 }')"
    echo "$request" >$metadata_file

    # Mount overlay
    mount -t overlay overlay -o "lowerdir=${cephfs_mount}/${sub_directory}${snapshot_path},upperdir=${tmp_work}/upper,workdir=${tmp_work}/work" "${mntpath}"
    chown 11042:11042 "${mntpath}"

    log '{"status":"Success"}'
    exit 0
}

unmount() {
    mntpath=$1

    # Locate metadata file
    metadata_file="/tmp/snaps/$(echo $mntpath | md5sum | awk '{ print $1 }')"
    request=$(cat $metadata_file)
    rm ${metadata_file} &>/dev/null

    # Read input
    workspace=$(echo $request | jq -r .workspace)
    directory_name=$(echo $request | jq -r .directoryName)
    snapshot_path=$(echo $request | jq -r .snapshotPath)
    real_path=$(echo $request | jq -r .realPath)
    sub_directory=$(echo $request | jq -r .cephSubDir)
    if [ "$sub_directory" == "null" ]
    then
        sub_directory=""
    fi

    # Move data to CephFS workspace upper
    tmp_work="/mnt/ofs/${workspace}_${directory_name}" &>/dev/null

    rm -rf "${cephfs_mount}/${sub_directory}workspace/${workspace}/snapshots/${directory_name}/upper" &>/dev/null
    mv "${tmp_work}/upper/" "${cephfs_mount}/${sub_directory}workspace/${workspace}/snapshots/${directory_name}/upper/" &>/dev/null
    rm -rf "${tmp_work}" &>/dev/null
    touch "${cephfs_mount}/${sub_directory}workspace/${workspace}/snapshots/${directory_name}/upper/.ucloud-ready"

    # Do the actual unmount
    umount $mntpath &>/dev/null

    log '{"status":"Success"}'
    exit 0
}

op=$1
shift

case "$op" in
init)
    log '{"status":"Success","capabilities":{"attach":false}}'
    exit 0
    ;;
mount)
    domount $*
    ;;
unmount)
    unmount $*
    ;;
*)
    log '{"status":"Not supported"}'
    exit 0
    ;;
esac

exit 1
