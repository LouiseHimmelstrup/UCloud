// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package main

import "encoding/json"
import "fmt"
import "reflect"

type AclEntity interface{}

type AllocationRequestsGroup string

const AllocationRequestsGroupALL AllocationRequestsGroup = "ALL"
const AllocationRequestsGroupPERSONAL AllocationRequestsGroup = "PERSONAL"
const AllocationRequestsGroupPROJECT AllocationRequestsGroup = "PROJECT"

type ArrayList []ArrayListElem

type ArrayListElem string

const ArrayListElemADMIN ArrayListElem = "ADMIN"
const ArrayListElemEDIT ArrayListElem = "EDIT"
const ArrayListElemPROVIDER ArrayListElem = "PROVIDER"
const ArrayListElemREAD ArrayListElem = "READ"

type ArrayList_1 interface{}

type Availability string

const AvailabilityMAJORDISRUPTION Availability = "MAJOR_DISRUPTION"
const AvailabilityMINORDISRUPTION Availability = "MINOR_DISRUPTION"
const AvailabilityNOSERVICE Availability = "NO_SERVICE"

type Boolean bool

type Boolean_1 interface{}

type ChargeType string

const ChargeTypeABSOLUTE ChargeType = "ABSOLUTE"
const ChargeTypeDIFFERENTIALQUOTA ChargeType = "DIFFERENTIAL_QUOTA"

type FSCollectionSupport struct {
    // AclModifiable corresponds to the JSON schema field "aclModifiable".
    AclModifiable FSCollectionSupportAclModifiable `json:"aclModifiable,omitempty" yaml:"aclModifiable,omitempty" mapstructure:"aclModifiable,omitempty"`

    // UsersCanCreate corresponds to the JSON schema field "usersCanCreate".
    UsersCanCreate FSCollectionSupportUsersCanCreate `json:"usersCanCreate,omitempty" yaml:"usersCanCreate,omitempty" mapstructure:"usersCanCreate,omitempty"`

    // UsersCanDelete corresponds to the JSON schema field "usersCanDelete".
    UsersCanDelete FSCollectionSupportUsersCanDelete `json:"usersCanDelete,omitempty" yaml:"usersCanDelete,omitempty" mapstructure:"usersCanDelete,omitempty"`

    // UsersCanRename corresponds to the JSON schema field "usersCanRename".
    UsersCanRename FSCollectionSupportUsersCanRename `json:"usersCanRename,omitempty" yaml:"usersCanRename,omitempty" mapstructure:"usersCanRename,omitempty"`
}

type FSCollectionSupportAclModifiable interface{}

type FSCollectionSupportUsersCanCreate interface{}

type FSCollectionSupportUsersCanDelete interface{}

type FSCollectionSupportUsersCanRename interface{}

type FSFileSupport struct {
    // AclModifiable corresponds to the JSON schema field "aclModifiable".
    AclModifiable *Boolean `json:"aclModifiable,omitempty" yaml:"aclModifiable,omitempty" mapstructure:"aclModifiable,omitempty"`

    // IsReadOnly corresponds to the JSON schema field "isReadOnly".
    IsReadOnly *Boolean `json:"isReadOnly,omitempty" yaml:"isReadOnly,omitempty" mapstructure:"isReadOnly,omitempty"`

    // SearchSupported corresponds to the JSON schema field "searchSupported".
    SearchSupported *Boolean `json:"searchSupported,omitempty" yaml:"searchSupported,omitempty" mapstructure:"searchSupported,omitempty"`

    // SharesSupported corresponds to the JSON schema field "sharesSupported".
    SharesSupported *Boolean `json:"sharesSupported,omitempty" yaml:"sharesSupported,omitempty" mapstructure:"sharesSupported,omitempty"`

    // StreamingSearchSupported corresponds to the JSON schema field
    // "streamingSearchSupported".
    StreamingSearchSupported *Boolean `json:"streamingSearchSupported,omitempty" yaml:"streamingSearchSupported,omitempty" mapstructure:"streamingSearchSupported,omitempty"`

    // TrashSupported corresponds to the JSON schema field "trashSupported".
    TrashSupported *Boolean `json:"trashSupported,omitempty" yaml:"trashSupported,omitempty" mapstructure:"trashSupported,omitempty"`
}

type FSProductStatsSupport struct {
    // AccessedAt corresponds to the JSON schema field "accessedAt".
    AccessedAt FSProductStatsSupportAccessedAt `json:"accessedAt,omitempty" yaml:"accessedAt,omitempty" mapstructure:"accessedAt,omitempty"`

    // CreatedAt corresponds to the JSON schema field "createdAt".
    CreatedAt FSProductStatsSupportCreatedAt `json:"createdAt,omitempty" yaml:"createdAt,omitempty" mapstructure:"createdAt,omitempty"`

    // ModifiedAt corresponds to the JSON schema field "modifiedAt".
    ModifiedAt FSProductStatsSupportModifiedAt `json:"modifiedAt,omitempty" yaml:"modifiedAt,omitempty" mapstructure:"modifiedAt,omitempty"`

    // SizeInBytes corresponds to the JSON schema field "sizeInBytes".
    SizeInBytes FSProductStatsSupportSizeInBytes `json:"sizeInBytes,omitempty" yaml:"sizeInBytes,omitempty" mapstructure:"sizeInBytes,omitempty"`

    // SizeIncludingChildrenInBytes corresponds to the JSON schema field
    // "sizeIncludingChildrenInBytes".
    SizeIncludingChildrenInBytes FSProductStatsSupportSizeIncludingChildrenInBytes `json:"sizeIncludingChildrenInBytes,omitempty" yaml:"sizeIncludingChildrenInBytes,omitempty" mapstructure:"sizeIncludingChildrenInBytes,omitempty"`

    // UnixGroup corresponds to the JSON schema field "unixGroup".
    UnixGroup FSProductStatsSupportUnixGroup `json:"unixGroup,omitempty" yaml:"unixGroup,omitempty" mapstructure:"unixGroup,omitempty"`

    // UnixOwner corresponds to the JSON schema field "unixOwner".
    UnixOwner FSProductStatsSupportUnixOwner `json:"unixOwner,omitempty" yaml:"unixOwner,omitempty" mapstructure:"unixOwner,omitempty"`

    // UnixPermissions corresponds to the JSON schema field "unixPermissions".
    UnixPermissions FSProductStatsSupportUnixPermissions `json:"unixPermissions,omitempty" yaml:"unixPermissions,omitempty" mapstructure:"unixPermissions,omitempty"`
}

type FSProductStatsSupportAccessedAt interface{}

type FSProductStatsSupportCreatedAt interface{}

type FSProductStatsSupportModifiedAt interface{}

type FSProductStatsSupportSizeInBytes interface{}

type FSProductStatsSupportSizeIncludingChildrenInBytes interface{}

type FSProductStatsSupportUnixGroup interface{}

type FSProductStatsSupportUnixOwner interface{}

type FSProductStatsSupportUnixPermissions interface{}

type FSSupport struct {
    // Collection corresponds to the JSON schema field "collection".
    Collection *FSCollectionSupport `json:"collection,omitempty" yaml:"collection,omitempty" mapstructure:"collection,omitempty"`

    // Files corresponds to the JSON schema field "files".
    Files *FSFileSupport `json:"files,omitempty" yaml:"files,omitempty" mapstructure:"files,omitempty"`

    // Maintenance corresponds to the JSON schema field "maintenance".
    Maintenance Maintenance `json:"maintenance,omitempty" yaml:"maintenance,omitempty" mapstructure:"maintenance,omitempty"`

    // Product corresponds to the JSON schema field "product".
    Product ProductReference `json:"product" yaml:"product" mapstructure:"product"`

    // Stats corresponds to the JSON schema field "stats".
    Stats *FSProductStatsSupport `json:"stats,omitempty" yaml:"stats,omitempty" mapstructure:"stats,omitempty"`
}

type FileIconHint string

const FileIconHintDIRECTORYJOBS FileIconHint = "DIRECTORY_JOBS"
const FileIconHintDIRECTORYSHARES FileIconHint = "DIRECTORY_SHARES"
const FileIconHintDIRECTORYSTAR FileIconHint = "DIRECTORY_STAR"
const FileIconHintDIRECTORYTRASH FileIconHint = "DIRECTORY_TRASH"

type FileMetadataHistory interface{}

type FileType string

const FileTypeDANGLINGMETADATA FileType = "DANGLING_METADATA"
const FileTypeDIRECTORY FileType = "DIRECTORY"
const FileTypeFILE FileType = "FILE"
const FileTypeSOFTLINK FileType = "SOFT_LINK"

type Int float64

type Int_1 interface{}

type LinkedHashMap map[string]ArrayList

type Long float64

type Long_1 interface{}

type Maintenance interface{}

type Permission string

const PermissionADMIN Permission = "ADMIN"
const PermissionEDIT Permission = "EDIT"
const PermissionPROVIDER Permission = "PROVIDER"
const PermissionREAD Permission = "READ"

type ProductCategoryId struct {
    // Name corresponds to the JSON schema field "name".
    Name String `json:"name" yaml:"name" mapstructure:"name"`

    // Provider corresponds to the JSON schema field "provider".
    Provider String `json:"provider" yaml:"provider" mapstructure:"provider"`
}

type ProductPriceUnit string

const ProductPriceUnitCREDITSPERDAY ProductPriceUnit = "CREDITS_PER_DAY"
const ProductPriceUnitCREDITSPERHOUR ProductPriceUnit = "CREDITS_PER_HOUR"
const ProductPriceUnitCREDITSPERMINUTE ProductPriceUnit = "CREDITS_PER_MINUTE"
const ProductPriceUnitCREDITSPERUNIT ProductPriceUnit = "CREDITS_PER_UNIT"
const ProductPriceUnitPERUNIT ProductPriceUnit = "PER_UNIT"
const ProductPriceUnitUNITSPERDAY ProductPriceUnit = "UNITS_PER_DAY"
const ProductPriceUnitUNITSPERHOUR ProductPriceUnit = "UNITS_PER_HOUR"
const ProductPriceUnitUNITSPERMINUTE ProductPriceUnit = "UNITS_PER_MINUTE"

type ProductReference struct {
    // Category corresponds to the JSON schema field "category".
    Category String `json:"category" yaml:"category" mapstructure:"category"`

    // Id corresponds to the JSON schema field "id".
    Id String `json:"id" yaml:"id" mapstructure:"id"`

    // Provider corresponds to the JSON schema field "provider".
    Provider String `json:"provider" yaml:"provider" mapstructure:"provider"`
}

type ProductType string

const ProductTypeCOMPUTE ProductType = "COMPUTE"
const ProductTypeINGRESS ProductType = "INGRESS"
const ProductTypeLICENSE ProductType = "LICENSE"
const ProductTypeNETWORKIP ProductType = "NETWORK_IP"
const ProductTypeSTORAGE ProductType = "STORAGE"

type ProjectGroup struct {
    // Group corresponds to the JSON schema field "group".
    Group String `json:"group" yaml:"group" mapstructure:"group"`

    // ProjectId corresponds to the JSON schema field "projectId".
    ProjectId String `json:"projectId" yaml:"projectId" mapstructure:"projectId"`
}

type ResolvedSupport interface{}

type ResourceAclEntry struct {
    // Entity corresponds to the JSON schema field "entity".
    Entity AclEntity `json:"entity" yaml:"entity" mapstructure:"entity"`

    // Permissions corresponds to the JSON schema field "permissions".
    Permissions ArrayList `json:"permissions" yaml:"permissions" mapstructure:"permissions"`
}

type ResourceOwner struct {
    // CreatedBy corresponds to the JSON schema field "createdBy".
    CreatedBy String `json:"createdBy" yaml:"createdBy" mapstructure:"createdBy"`

    // Project corresponds to the JSON schema field "project".
    Project ResourceOwnerProject `json:"project" yaml:"project" mapstructure:"project"`
}

type ResourceOwnerProject interface{}

type ResourcePermissions interface{}

type Storage interface{}

type StorageAllowAllocationRequestsFrom string

const StorageAllowAllocationRequestsFromALL StorageAllowAllocationRequestsFrom = "ALL"
const StorageAllowAllocationRequestsFromPERSONAL StorageAllowAllocationRequestsFrom = "PERSONAL"
const StorageAllowAllocationRequestsFromPROJECT StorageAllowAllocationRequestsFrom = "PROJECT"

type StorageBalance interface{}

type StorageChargeType string

const StorageChargeTypeABSOLUTE StorageChargeType = "ABSOLUTE"
const StorageChargeTypeDIFFERENTIALQUOTA StorageChargeType = "DIFFERENTIAL_QUOTA"

type StorageMaxUsableBalance interface{}

type StorageProductType string

const StorageProductTypeCOMPUTE StorageProductType = "COMPUTE"
const StorageProductTypeINGRESS StorageProductType = "INGRESS"
const StorageProductTypeLICENSE StorageProductType = "LICENSE"
const StorageProductTypeNETWORKIP StorageProductType = "NETWORK_IP"
const StorageProductTypeSTORAGE StorageProductType = "STORAGE"

type StorageUnitOfPrice string

const StorageUnitOfPriceCREDITSPERDAY StorageUnitOfPrice = "CREDITS_PER_DAY"
const StorageUnitOfPriceCREDITSPERHOUR StorageUnitOfPrice = "CREDITS_PER_HOUR"
const StorageUnitOfPriceCREDITSPERMINUTE StorageUnitOfPrice = "CREDITS_PER_MINUTE"
const StorageUnitOfPriceCREDITSPERUNIT StorageUnitOfPrice = "CREDITS_PER_UNIT"
const StorageUnitOfPricePERUNIT StorageUnitOfPrice = "PER_UNIT"
const StorageUnitOfPriceUNITSPERDAY StorageUnitOfPrice = "UNITS_PER_DAY"
const StorageUnitOfPriceUNITSPERHOUR StorageUnitOfPrice = "UNITS_PER_HOUR"
const StorageUnitOfPriceUNITSPERMINUTE StorageUnitOfPrice = "UNITS_PER_MINUTE"

type Storage_1 struct {
    // AllowAllocationRequestsFrom corresponds to the JSON schema field
    // "allowAllocationRequestsFrom".
    AllowAllocationRequestsFrom *StorageAllowAllocationRequestsFrom `json:"allowAllocationRequestsFrom,omitempty" yaml:"allowAllocationRequestsFrom,omitempty" mapstructure:"allowAllocationRequestsFrom,omitempty"`

    // Balance corresponds to the JSON schema field "balance".
    Balance StorageBalance `json:"balance,omitempty" yaml:"balance,omitempty" mapstructure:"balance,omitempty"`

    // Category corresponds to the JSON schema field "category".
    Category ProductCategoryId `json:"category" yaml:"category" mapstructure:"category"`

    // ChargeType corresponds to the JSON schema field "chargeType".
    ChargeType *StorageChargeType `json:"chargeType,omitempty" yaml:"chargeType,omitempty" mapstructure:"chargeType,omitempty"`

    // Description corresponds to the JSON schema field "description".
    Description *String `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

    // FreeToUse corresponds to the JSON schema field "freeToUse".
    FreeToUse *Boolean `json:"freeToUse,omitempty" yaml:"freeToUse,omitempty" mapstructure:"freeToUse,omitempty"`

    // HiddenInGrantApplications corresponds to the JSON schema field
    // "hiddenInGrantApplications".
    HiddenInGrantApplications *Boolean `json:"hiddenInGrantApplications,omitempty" yaml:"hiddenInGrantApplications,omitempty" mapstructure:"hiddenInGrantApplications,omitempty"`

    // MaxUsableBalance corresponds to the JSON schema field "maxUsableBalance".
    MaxUsableBalance StorageMaxUsableBalance `json:"maxUsableBalance,omitempty" yaml:"maxUsableBalance,omitempty" mapstructure:"maxUsableBalance,omitempty"`

    // Name corresponds to the JSON schema field "name".
    Name String `json:"name" yaml:"name" mapstructure:"name"`

    // PricePerUnit corresponds to the JSON schema field "pricePerUnit".
    PricePerUnit Long `json:"pricePerUnit" yaml:"pricePerUnit" mapstructure:"pricePerUnit"`

    // Priority corresponds to the JSON schema field "priority".
    Priority *Int `json:"priority,omitempty" yaml:"priority,omitempty" mapstructure:"priority,omitempty"`

    // ProductType corresponds to the JSON schema field "productType".
    ProductType *StorageProductType `json:"productType,omitempty" yaml:"productType,omitempty" mapstructure:"productType,omitempty"`

    // UnitOfPrice corresponds to the JSON schema field "unitOfPrice".
    UnitOfPrice *StorageUnitOfPrice `json:"unitOfPrice,omitempty" yaml:"unitOfPrice,omitempty" mapstructure:"unitOfPrice,omitempty"`

    // Version corresponds to the JSON schema field "version".
    Version *Int `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type String string

type String_1 interface{}

type UFile struct {
    // CreatedAt corresponds to the JSON schema field "createdAt".
    CreatedAt Long `json:"createdAt" yaml:"createdAt" mapstructure:"createdAt"`

    // Id corresponds to the JSON schema field "id".
    Id String `json:"id" yaml:"id" mapstructure:"id"`

    // Owner corresponds to the JSON schema field "owner".
    Owner ResourceOwner `json:"owner" yaml:"owner" mapstructure:"owner"`

    // Permissions corresponds to the JSON schema field "permissions".
    Permissions ResourcePermissions `json:"permissions,omitempty" yaml:"permissions,omitempty" mapstructure:"permissions,omitempty"`

    // Specification corresponds to the JSON schema field "specification".
    Specification UFileSpecification `json:"specification" yaml:"specification" mapstructure:"specification"`

    // Status corresponds to the JSON schema field "status".
    Status UFileStatus `json:"status" yaml:"status" mapstructure:"status"`

    // Updates corresponds to the JSON schema field "updates".
    Updates ArrayList `json:"updates,omitempty" yaml:"updates,omitempty" mapstructure:"updates,omitempty"`
}

type UFileSpecification struct {
    // Collection corresponds to the JSON schema field "collection".
    Collection String `json:"collection" yaml:"collection" mapstructure:"collection"`

    // Product corresponds to the JSON schema field "product".
    Product ProductReference `json:"product" yaml:"product" mapstructure:"product"`
}

type UFileStatus struct {
    // AccessedAt corresponds to the JSON schema field "accessedAt".
    AccessedAt UFileStatusAccessedAt `json:"accessedAt,omitempty" yaml:"accessedAt,omitempty" mapstructure:"accessedAt,omitempty"`

    // Icon corresponds to the JSON schema field "icon".
    Icon *UFileStatusIcon `json:"icon,omitempty" yaml:"icon,omitempty" mapstructure:"icon,omitempty"`

    // Metadata corresponds to the JSON schema field "metadata".
    Metadata FileMetadataHistory `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

    // ModifiedAt corresponds to the JSON schema field "modifiedAt".
    ModifiedAt UFileStatusModifiedAt `json:"modifiedAt,omitempty" yaml:"modifiedAt,omitempty" mapstructure:"modifiedAt,omitempty"`

    // ResolvedProduct corresponds to the JSON schema field "resolvedProduct".
    ResolvedProduct Storage `json:"resolvedProduct,omitempty" yaml:"resolvedProduct,omitempty" mapstructure:"resolvedProduct,omitempty"`

    // ResolvedSupport corresponds to the JSON schema field "resolvedSupport".
    ResolvedSupport ResolvedSupport `json:"resolvedSupport,omitempty" yaml:"resolvedSupport,omitempty" mapstructure:"resolvedSupport,omitempty"`

    // SizeInBytes corresponds to the JSON schema field "sizeInBytes".
    SizeInBytes UFileStatusSizeInBytes `json:"sizeInBytes,omitempty" yaml:"sizeInBytes,omitempty" mapstructure:"sizeInBytes,omitempty"`

    // SizeIncludingChildrenInBytes corresponds to the JSON schema field
    // "sizeIncludingChildrenInBytes".
    SizeIncludingChildrenInBytes UFileStatusSizeIncludingChildrenInBytes `json:"sizeIncludingChildrenInBytes,omitempty" yaml:"sizeIncludingChildrenInBytes,omitempty" mapstructure:"sizeIncludingChildrenInBytes,omitempty"`

    // Type corresponds to the JSON schema field "type".
    Type *UFileStatusType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

    // UnixGroup corresponds to the JSON schema field "unixGroup".
    UnixGroup UFileStatusUnixGroup `json:"unixGroup,omitempty" yaml:"unixGroup,omitempty" mapstructure:"unixGroup,omitempty"`

    // UnixMode corresponds to the JSON schema field "unixMode".
    UnixMode UFileStatusUnixMode `json:"unixMode,omitempty" yaml:"unixMode,omitempty" mapstructure:"unixMode,omitempty"`

    // UnixOwner corresponds to the JSON schema field "unixOwner".
    UnixOwner UFileStatusUnixOwner `json:"unixOwner,omitempty" yaml:"unixOwner,omitempty" mapstructure:"unixOwner,omitempty"`
}

type UFileStatusAccessedAt interface{}

type UFileStatusIcon string

const UFileStatusIconDIRECTORYJOBS UFileStatusIcon = "DIRECTORY_JOBS"
const UFileStatusIconDIRECTORYSHARES UFileStatusIcon = "DIRECTORY_SHARES"
const UFileStatusIconDIRECTORYSTAR UFileStatusIcon = "DIRECTORY_STAR"
const UFileStatusIconDIRECTORYTRASH UFileStatusIcon = "DIRECTORY_TRASH"

type UFileStatusModifiedAt interface{}

type UFileStatusSizeInBytes interface{}

type UFileStatusSizeIncludingChildrenInBytes interface{}

type UFileStatusType string

const UFileStatusTypeDANGLINGMETADATA UFileStatusType = "DANGLING_METADATA"
const UFileStatusTypeDIRECTORY UFileStatusType = "DIRECTORY"
const UFileStatusTypeFILE UFileStatusType = "FILE"
const UFileStatusTypeSOFTLINK UFileStatusType = "SOFT_LINK"

type UFileStatusUnixGroup interface{}

type UFileStatusUnixMode interface{}

type UFileStatusUnixOwner interface{}

type User struct {
    // Username corresponds to the JSON schema field "username".
    Username String `json:"username" yaml:"username" mapstructure:"username"`
}

var enumValues_AllocationRequestsGroup = []interface{}{
    "ALL",
    "PERSONAL",
    "PROJECT",
}
var enumValues_ArrayListElem = []interface{}{
    "READ",
    "EDIT",
    "ADMIN",
    "PROVIDER",
}
var enumValues_Availability = []interface{}{
    "MINOR_DISRUPTION",
    "MAJOR_DISRUPTION",
    "NO_SERVICE",
}
var enumValues_ChargeType = []interface{}{
    "ABSOLUTE",
    "DIFFERENTIAL_QUOTA",
}
var enumValues_FileIconHint = []interface{}{
    "DIRECTORY_STAR",
    "DIRECTORY_SHARES",
    "DIRECTORY_TRASH",
    "DIRECTORY_JOBS",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResourceOwner) UnmarshalJSON(b []byte) error {
    var raw map[string]interface{}
    if err := json.Unmarshal(b, &raw); err != nil {
        return err
    }
    if v, ok := raw["createdBy"]; !ok || v == nil {
        return fmt.Errorf("field createdBy in ResourceOwner: required")
    }
    if v, ok := raw["project"]; !ok || v == nil {
        return fmt.Errorf("field project in ResourceOwner: required")
    }
    type Plain ResourceOwner
    var plain Plain
    if err := json.Unmarshal(b, &plain); err != nil {
        return err
    }
    *j = ResourceOwner(plain)
    return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StorageAllowAllocationRequestsFrom) UnmarshalJSON(b []byte) error {
    var v string
    if err := json.Unmarshal(b, &v); err != nil {
        return err
    }
    var ok bool
    for _, expected := range enumValues_StorageAllowAllocationRequestsFrom {
        if reflect.DeepEqual(v, expected) {
            ok = true
            break
        }
    }
    if !ok {
        return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StorageAllowAllocationRequestsFrom, v)
    }
    *j = StorageAllowAllocationRequestsFrom(v)
    return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FSSupport) UnmarshalJSON(b []byte) error {
    var raw map[string]interface{}
    if err := json.Unmarshal(b, &raw); err != nil {
        return err
    }
    if v, ok := raw["product"]; !ok || v == nil {
        return fmt.Errorf("field product in FSSupport: required")
    }
    type Plain FSSupport
    var plain Plain
    if err := json.Unmarshal(b, &plain); err != nil {
        return err
    }
    *j = FSSupport(plain)
    return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProductReference) UnmarshalJSON(b []byte) error {
    var raw map[string]interface{}
    if err := json.Unmarshal(b, &raw); err != nil {
        return err
    }
    if v, ok := raw["category"]; !ok || v == nil {
        return fmt.Errorf("field category in ProductReference: required")
    }
    if v, ok := raw["id"]; !ok || v == nil {
        return fmt.Errorf("field id in ProductReference: required")
    }
    if v, ok := raw["provider"]; !ok || v == nil {
        return fmt.Errorf("field provider in ProductReference: required")
    }
    type Plain ProductReference
    var plain Plain
    if err := json.Unmarshal(b, &plain); err != nil {
        return err
    }
    *j = ProductReference(plain)
    return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FileIconHint) UnmarshalJSON(b []byte) error {
    var v string
    if err := json.Unmarshal(b, &v); err != nil {
        return err
    }
    var ok bool
    for _, expected := range enumValues_FileIconHint {
        if reflect.DeepEqual(v, expected) {
            ok = true
            break
        }
    }
    if !ok {
        return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_FileIconHint, v)
    }
    *j = FileIconHint(v)
    return nil
}

var enumValues_FileType = []interface{}{
    "FILE",
    "DIRECTORY",
    "SOFT_LINK",
    "DANGLING_METADATA",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FileType) UnmarshalJSON(b []byte) error {
    var v string
    if err := json.Unmarshal(b, &v); err != nil {
        return err
    }
    var ok bool
    for _, expected := range enumValues_FileType {
        if reflect.DeepEqual(v, expected) {
            ok = true
            break
        }
    }
    if !ok {
        return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_FileType, v)
    }
    *j = FileType(v)
    return nil
}

var enumValues_StorageChargeType = []interface{}{
    "ABSOLUTE",
    "DIFFERENTIAL_QUOTA",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StorageChargeType) UnmarshalJSON(b []byte) error {
    var v string
    if err := json.Unmarshal(b, &v); err != nil {
        return err
    }
    var ok bool
    for _, expected := range enumValues_StorageChargeType {
        if reflect.DeepEqual(v, expected) {
            ok = true
            break
        }
    }
    if !ok {
        return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StorageChargeType, v)
    }
    *j = StorageChargeType(v)
    return nil
}

var enumValues_UFileStatusType = []interface{}{
    "FILE",
    "DIRECTORY",
    "SOFT_LINK",
    "DANGLING_METADATA",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Permission) UnmarshalJSON(b []byte) error {
    var v string
    if err := json.Unmarshal(b, &v); err != nil {
        return err
    }
    var ok bool
    for _, expected := range enumValues_Permission {
        if reflect.DeepEqual(v, expected) {
            ok = true
            break
        }
    }
    if !ok {
        return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Permission, v)
    }
    *j = Permission(v)
    return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UFileStatusIcon) UnmarshalJSON(b []byte) error {
    var v string
    if err := json.Unmarshal(b, &v); err != nil {
        return err
    }
    var ok bool
    for _, expected := range enumValues_UFileStatusIcon {
        if reflect.DeepEqual(v, expected) {
            ok = true
            break
        }
    }
    if !ok {
        return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UFileStatusIcon, v)
    }
    *j = UFileStatusIcon(v)
    return nil
}

var enumValues_UFileStatusIcon = []interface{}{
    "DIRECTORY_STAR",
    "DIRECTORY_SHARES",
    "DIRECTORY_TRASH",
    "DIRECTORY_JOBS",
}
var enumValues_StorageProductType = []interface{}{
    "STORAGE",
    "COMPUTE",
    "INGRESS",
    "LICENSE",
    "NETWORK_IP",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StorageProductType) UnmarshalJSON(b []byte) error {
    var v string
    if err := json.Unmarshal(b, &v); err != nil {
        return err
    }
    var ok bool
    for _, expected := range enumValues_StorageProductType {
        if reflect.DeepEqual(v, expected) {
            ok = true
            break
        }
    }
    if !ok {
        return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StorageProductType, v)
    }
    *j = StorageProductType(v)
    return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UFileSpecification) UnmarshalJSON(b []byte) error {
    var raw map[string]interface{}
    if err := json.Unmarshal(b, &raw); err != nil {
        return err
    }
    if v, ok := raw["collection"]; !ok || v == nil {
        return fmt.Errorf("field collection in UFileSpecification: required")
    }
    if v, ok := raw["product"]; !ok || v == nil {
        return fmt.Errorf("field product in UFileSpecification: required")
    }
    type Plain UFileSpecification
    var plain Plain
    if err := json.Unmarshal(b, &plain); err != nil {
        return err
    }
    *j = UFileSpecification(plain)
    return nil
}

var enumValues_StorageAllowAllocationRequestsFrom = []interface{}{
    "ALL",
    "PERSONAL",
    "PROJECT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChargeType) UnmarshalJSON(b []byte) error {
    var v string
    if err := json.Unmarshal(b, &v); err != nil {
        return err
    }
    var ok bool
    for _, expected := range enumValues_ChargeType {
        if reflect.DeepEqual(v, expected) {
            ok = true
            break
        }
    }
    if !ok {
        return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ChargeType, v)
    }
    *j = ChargeType(v)
    return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProjectGroup) UnmarshalJSON(b []byte) error {
    var raw map[string]interface{}
    if err := json.Unmarshal(b, &raw); err != nil {
        return err
    }
    if v, ok := raw["group"]; !ok || v == nil {
        return fmt.Errorf("field group in ProjectGroup: required")
    }
    if v, ok := raw["projectId"]; !ok || v == nil {
        return fmt.Errorf("field projectId in ProjectGroup: required")
    }
    type Plain ProjectGroup
    var plain Plain
    if err := json.Unmarshal(b, &plain); err != nil {
        return err
    }
    *j = ProjectGroup(plain)
    return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResourceAclEntry) UnmarshalJSON(b []byte) error {
    var raw map[string]interface{}
    if err := json.Unmarshal(b, &raw); err != nil {
        return err
    }
    if v, ok := raw["entity"]; !ok || v == nil {
        return fmt.Errorf("field entity in ResourceAclEntry: required")
    }
    if v, ok := raw["permissions"]; !ok || v == nil {
        return fmt.Errorf("field permissions in ResourceAclEntry: required")
    }
    type Plain ResourceAclEntry
    var plain Plain
    if err := json.Unmarshal(b, &plain); err != nil {
        return err
    }
    *j = ResourceAclEntry(plain)
    return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Availability) UnmarshalJSON(b []byte) error {
    var v string
    if err := json.Unmarshal(b, &v); err != nil {
        return err
    }
    var ok bool
    for _, expected := range enumValues_Availability {
        if reflect.DeepEqual(v, expected) {
            ok = true
            break
        }
    }
    if !ok {
        return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Availability, v)
    }
    *j = Availability(v)
    return nil
}

var enumValues_StorageUnitOfPrice = []interface{}{
    "CREDITS_PER_UNIT",
    "PER_UNIT",
    "CREDITS_PER_MINUTE",
    "CREDITS_PER_HOUR",
    "CREDITS_PER_DAY",
    "UNITS_PER_MINUTE",
    "UNITS_PER_HOUR",
    "UNITS_PER_DAY",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StorageUnitOfPrice) UnmarshalJSON(b []byte) error {
    var v string
    if err := json.Unmarshal(b, &v); err != nil {
        return err
    }
    var ok bool
    for _, expected := range enumValues_StorageUnitOfPrice {
        if reflect.DeepEqual(v, expected) {
            ok = true
            break
        }
    }
    if !ok {
        return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StorageUnitOfPrice, v)
    }
    *j = StorageUnitOfPrice(v)
    return nil
}

var enumValues_Permission = []interface{}{
    "READ",
    "EDIT",
    "ADMIN",
    "PROVIDER",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProductCategoryId) UnmarshalJSON(b []byte) error {
    var raw map[string]interface{}
    if err := json.Unmarshal(b, &raw); err != nil {
        return err
    }
    if v, ok := raw["name"]; !ok || v == nil {
        return fmt.Errorf("field name in ProductCategoryId: required")
    }
    if v, ok := raw["provider"]; !ok || v == nil {
        return fmt.Errorf("field provider in ProductCategoryId: required")
    }
    type Plain ProductCategoryId
    var plain Plain
    if err := json.Unmarshal(b, &plain); err != nil {
        return err
    }
    *j = ProductCategoryId(plain)
    return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ArrayListElem) UnmarshalJSON(b []byte) error {
    var v string
    if err := json.Unmarshal(b, &v); err != nil {
        return err
    }
    var ok bool
    for _, expected := range enumValues_ArrayListElem {
        if reflect.DeepEqual(v, expected) {
            ok = true
            break
        }
    }
    if !ok {
        return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ArrayListElem, v)
    }
    *j = ArrayListElem(v)
    return nil
}

var enumValues_ProductPriceUnit = []interface{}{
    "CREDITS_PER_UNIT",
    "PER_UNIT",
    "CREDITS_PER_MINUTE",
    "CREDITS_PER_HOUR",
    "CREDITS_PER_DAY",
    "UNITS_PER_MINUTE",
    "UNITS_PER_HOUR",
    "UNITS_PER_DAY",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProductPriceUnit) UnmarshalJSON(b []byte) error {
    var v string
    if err := json.Unmarshal(b, &v); err != nil {
        return err
    }
    var ok bool
    for _, expected := range enumValues_ProductPriceUnit {
        if reflect.DeepEqual(v, expected) {
            ok = true
            break
        }
    }
    if !ok {
        return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProductPriceUnit, v)
    }
    *j = ProductPriceUnit(v)
    return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UFile) UnmarshalJSON(b []byte) error {
    var raw map[string]interface{}
    if err := json.Unmarshal(b, &raw); err != nil {
        return err
    }
    if v, ok := raw["createdAt"]; !ok || v == nil {
        return fmt.Errorf("field createdAt in UFile: required")
    }
    if v, ok := raw["id"]; !ok || v == nil {
        return fmt.Errorf("field id in UFile: required")
    }
    if v, ok := raw["owner"]; !ok || v == nil {
        return fmt.Errorf("field owner in UFile: required")
    }
    if v, ok := raw["specification"]; !ok || v == nil {
        return fmt.Errorf("field specification in UFile: required")
    }
    if v, ok := raw["status"]; !ok || v == nil {
        return fmt.Errorf("field status in UFile: required")
    }
    type Plain UFile
    var plain Plain
    if err := json.Unmarshal(b, &plain); err != nil {
        return err
    }
    *j = UFile(plain)
    return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProductType) UnmarshalJSON(b []byte) error {
    var v string
    if err := json.Unmarshal(b, &v); err != nil {
        return err
    }
    var ok bool
    for _, expected := range enumValues_ProductType {
        if reflect.DeepEqual(v, expected) {
            ok = true
            break
        }
    }
    if !ok {
        return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProductType, v)
    }
    *j = ProductType(v)
    return nil
}

var enumValues_ProductType = []interface{}{
    "STORAGE",
    "COMPUTE",
    "INGRESS",
    "LICENSE",
    "NETWORK_IP",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AllocationRequestsGroup) UnmarshalJSON(b []byte) error {
    var v string
    if err := json.Unmarshal(b, &v); err != nil {
        return err
    }
    var ok bool
    for _, expected := range enumValues_AllocationRequestsGroup {
        if reflect.DeepEqual(v, expected) {
            ok = true
            break
        }
    }
    if !ok {
        return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AllocationRequestsGroup, v)
    }
    *j = AllocationRequestsGroup(v)
    return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Storage_1) UnmarshalJSON(b []byte) error {
    var raw map[string]interface{}
    if err := json.Unmarshal(b, &raw); err != nil {
        return err
    }
    if v, ok := raw["category"]; !ok || v == nil {
        return fmt.Errorf("field category in Storage_1: required")
    }
    if v, ok := raw["name"]; !ok || v == nil {
        return fmt.Errorf("field name in Storage_1: required")
    }
    if v, ok := raw["pricePerUnit"]; !ok || v == nil {
        return fmt.Errorf("field pricePerUnit in Storage_1: required")
    }
    type Plain Storage_1
    var plain Plain
    if err := json.Unmarshal(b, &plain); err != nil {
        return err
    }
    *j = Storage_1(plain)
    return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UFileStatusType) UnmarshalJSON(b []byte) error {
    var v string
    if err := json.Unmarshal(b, &v); err != nil {
        return err
    }
    var ok bool
    for _, expected := range enumValues_UFileStatusType {
        if reflect.DeepEqual(v, expected) {
            ok = true
            break
        }
    }
    if !ok {
        return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UFileStatusType, v)
    }
    *j = UFileStatusType(v)
    return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *User) UnmarshalJSON(b []byte) error {
    var raw map[string]interface{}
    if err := json.Unmarshal(b, &raw); err != nil {
        return err
    }
    if v, ok := raw["username"]; !ok || v == nil {
        return fmt.Errorf("field username in User: required")
    }
    type Plain User
    var plain Plain
    if err := json.Unmarshal(b, &plain); err != nil {
        return err
    }
    *j = User(plain)
    return nil
}
